<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>
  <title>Trails Tutorial</title>

  <section>
    <title>The beginning</title>

    <para>This tutorial will walk you through the process of developing an
    application in Trails. As you will see this process is radically simpler
    and faster than developing a typical Java web application. Along the way,
    I hope to introduce most of the important features of Trails. Since Trails
    is inspired by frameworks like Rails, we will use the blogging application
    that Rails uses as the example application for this tutorial. This
    tutorial also assumes you have already gone through the Trails Quickstart
    guide, and proceeds from there.</para>

    <para>Trails leverages several other frameworks to provide key services
    such as web presentation, database persistence, and dependency injection.
    While detailed knowledge of these frameworks should not be necessary to
    build an application using Trails, a basic understanding will be helpful.
    Here are the frameworks currently used by Trails</para>

    <table>
      <title>Frameworks currently used in Trails</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry><interface>Hibernate</interface></entry>

            <entry>Used for persistence of domain objects to an RDBMS</entry>
          </row>

          <row>
            <entry><interface>Spring</interface></entry>

            <entry>Dependency injection and configuration</entry>
          </row>

          <row>
            <entry><interface>Tapestry</interface></entry>

            <entry>Web application framework</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>
  </section>

  <section>
    <title>First things first</title>

    <para>Trails is a domain driven development framework. Domain driven
    development is really just a fancy word for object oriented programming.
    The goal of DDD is to enable you to focus on developing a rich domain
    model for your application. Trails will automagically expose a web UI for
    your domain model and take care of persisting your domain objects to an
    RDBMS.</para>

    <para>So that said, hopefully it logically follows that the first thing
    you are going to do in a Trails application is develop an object. This
    should be a POJO with JSR-220 persistencea annotationsb which tell
    Hibernate how to persist your objects to an RDBMS.</para>

    <para>So let's start with a very simple object to represent a Blog.</para>

    <programlisting>package org.trails.tutorial;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class Blog
{
    private Integer id;
    
    private String name;
    
    private String author;
    
    /**
     * @hibernate.property 
     * @return Returns the author.
     */
    public String getAuthor()
    {
        return author;
    }
    /**
     * @param author The author to set.
     */
    public void setAuthor(String author)
    {
        this.author = author;
    }
    /**
     * @return Returns the id.
     * @hibernate.id
     *   generator-class = "native"
     */
    public Integer getId()
    {
        return id;
    }
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    /**
     * @hibernate.property
     * @return Returns the name.
     */
    public String getName()
    {
        return name;
    }
    /**
     * @param name The name to set.
     */
    public void setName(String name)
    {
        this.name = name;
    }
}

</programlisting>

    <para>So this is a what the simplest Trails application looks like: a POJO
    with some <ulink url="http://xdoclet.sourceforge.net/hibernate/">Xdoclet
    comments</ulink>. The Xdoclet comments are optional, but since Trails uses
    Hibernate for persistence by default you will need to provide the
    Hibernate mapping files. By using Xdoclet comments, your project's
    build.xml file will invoke hibernatedoclet to produce these mappings
    automatically. We have our blog class with a couple of properties for
    <property>name</property> and <property>author</property>, and an Integer
    <property>id</property> property. It's worth pointing out that we need
    this id property. In a Trails application, we need an identifier property
    for Hibernate to be happy. A totally synthetic property with no intrinsic
    meaning is usually best. Yes, purists will argue this is in an intrusion
    to our lovely pure OO domain model. I won't argue, but for now, in Trails
    this is just the price of RDBMS persistence.</para>

    <para>Ok, enough talk, let's see what this looks like. Startup your Tomcat
    instance, if you don't already have it running. Then run <command>ant
    deploy</command>. Go the url for your application, which if you named your
    application <literal>blogger</literal> and run tomcat on port 8080 would
    be <ulink url="???">http://localhost:8080/blog</ulink>. On the first page
    of the application, you will see a link to the List Blogs page. From here,
    you can create a New Blog, etc.</para>
  </section>

  <section>
    <title>Relationships</title>

    <para>At this point we have a fully functional (though very minimal) web
    application complete with database persistence. But it's not very
    interesting. In order to build a useful application, we will need more
    than CRUD screens against each object. We also need to manipulate the
    relationships between those objects.</para>

    <section>
      <title>One-to-many relationships</title>

      <para>As the next step in building a Blog application, we really need to
      add blog entries to a Blog. First, let's create a BlogEntry
      class:</para>

      <programlisting>
package org.trails.tutorial;

import java.util.Date;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class BlogEntry
{
    private Integer id;
    
    private String entry;
    
    private Date publishDate;
    
    private String title;
    
    /**
     * @hibernate.property
     * @return Returns the entry.
     */
    public String getEntry()
    {
        return entry;
    }
    
    /**
     * @param entry The entry to set.
     */
    public void setEntry(String entry)
    {
        this.entry = entry;
    }
    
    /**
     * @hibernate.id
     *   generator-class = "native"
     * @return Returns the id.
     */
    public Integer getId()
    {
        return id;
    }
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    
    /**
     * @hibernate.property
     * @return Returns the publishDate.
     */
    public Date getPublishDate()
    {
        return publishDate;
    }
    /**
     * @param publishDate The publishDate to set.
     */
    public void setPublishDate(Date publishDate)
    {
        this.publishDate = publishDate;
    }
    
    /**
     * @return Returns the title.
     */
    public String getTitle()
    {
        return title;
    }
    /**
     * @param title The title to set.
     */
    public void setTitle(String title)
    {
        this.title = title;
    }
    
    public String toString() { return title; }
    
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj)
    {
        return ((BlogEntry)obj).getId().equals(getId());
    }
}
</programlisting>

      <para>One important thing is worth pointing out: the
      <methodname>toString()</methodname> method. This method is more than
      just a good idea, in Trails it is vital to displaying this object
      properly. When an object can be related to another object (such as
      <classname>Blog</classname>), Trails will use the
      <methodname>toString()</methodname> method in rendering these objects.
      In this example when editing <classname>Blog</classname> we will see all
      the <classname>BlogEntry</classname>s. Trails will use the toString()
      method of <classname>BlogEntry</classname> to display these. Let's start
      by adding a Set of blog entries to our Blog class:</para>

      <programlisting>    /**
     * @return Returns the entries.
     * @hibernate.set cascade="all-delete-orphan"
     * @hibernate.collection-key column="ENTRY_ID"
     * @hibernate.collection-one-to-many class="org.trails.tutorial.BlogEntry"
     */
    public Set getEntries()
    {
        return entries;
    }
    
    /**
     * @param entries The entries to set.
     */
    public void setEntries(Set entries)
    {
        this.entries = entries;
    }</programlisting>

      <para>There's a couple of things to point out here. The first of these
      is that this is a one-to-many relationship from Blog to BlogEntry.
      Trails will present an appropriate UI to interact with many-to-one and
      one-to-many relationships. We will see a many-to-one relationship
      example later.</para>

      <para>Notice the Xdoclet comment here. This is all necessary to tell
      Hibernate how to persist this Set. In addition, the
      <computeroutput>cascade="all-delete-orphan"</computeroutput> is
      particularly significant to Trails. Based on this, Trails assumes that
      this is a child relationship, which means that it will be rendered with
      a component that will allow you insert new
      <classname>BlogEntry</classname>s and remove them. If this was not a
      child relationship, you would also be able to add existing BlogEntrys,
      and Trails would present a list of all BlogEntrys to choose from. Since
      it really doesn't make sense to choose BlogEntrys from (possibly) a
      different Blog, we want this to be a child relationship.</para>

      <para>Ok, enough talk, let's see this in action. Run the
      <command>redeploy</command> target to see our application in action. We
      now have are able to create a Blog and create BlogEntrys within that
      Blog.</para>

      <para><tip>
          <para>By default, for ease of demoing, Trails ships with HSQL
          database running in file mode. This will not handle redeploys
          gracefully due to file locking issues with HSQL. You may therefore
          want to use MySQL or run HSQL in server mode.</para>
        </tip></para>
    </section>

    <section>
      <title>Many-to-one relationships</title>

      <para>Another typical feature we would like to have in a blogging
      application is the ability to categorize our blog entries. First, let's
      create a <classname>Category</classname> class.</para>

      <programlisting>package org.trails.tutorial;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class Category
{
    private Integer id;
    
    private String name;
    
    /**
     * @hibernate.id
     *   generator-class = "native"
     * @return Returns the id.
     */
    public Integer getId()
    {
        return id;
    }
    
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    
    /**
     * @return Returns the name.
     * @hibernate.property
     */
    public String getName()
    {
        return name;
    }
    /**
     * @param name The name to set.
     */
    public void setName(String name)
    {
        this.name = name;
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj)
    {
        return ((Category)obj).getId().equals(getId());
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#toString()
     */
    public String toString()
    {
        return getName();
    }
}
</programlisting>

      <para>Here again it is important for us to override the
      <methodname>equals</methodname> and <methodname>toString</methodname>
      methods. We need the <methodname>toString</methodname> method to
      correctly display categories in a select list on the BlogEntry class, as
      we shall see in a moment. Now we need to add a category field to the
      BlogEntry class:</para>

      <programlisting>    private Category category;
    
    /**
     * @hibernate.many-to-one 
     */
    public Category getCategory()
    {
        return category;
    }
    
    /**
     * @param category The category to set.
     */
    public void setCategory(Category category)
    {
        this.category = category;
    }</programlisting>

      <para>As you can see this is actually quite a bit simpler than the
      one-to-many. When we run the <command>redeploy</command> target we will
      see that BlogEntry page now has a select list of categories. Of course
      we will need to create some categories before we have any to add.</para>
    </section>
  </section>

  <section>
    <title>Customization</title>

    <para>So far we've seen what Trails can do just based on our object model
    alone. Trails uses the approach of assuming as much as we possibly can,
    but lets us override those assumptions whenever we need to. Let's explore
    how we can customize our blogging application. In Trails, there are two
    basic ways we can customize.</para>

    <para></para>

    <section>
      <title>Customizing pages in Trails</title>

      <para>Right now, Trails uses Tapestry as it's web MVC framework, so all
      pages in Trails are Tapestry pages. <footnoteref id="footnoteref1"
      linkend="footenote1" />There are 2 basic types of pages in Trails: pages
      which extend <classname>ListPage</classname> and pages which extend
      <classname>EditPage</classname>. Pages which extend ListPage display a
      list of objects of a given type, while those that extend
      <classname>EditPage</classname> allow a user to edit a selected
      instance.</para>

      <para>Trails determines which specific page to use by first attempting
      to find a page for a specific class by calling
      <methodname>cycle.getPage()</methodname> with the unqualified class name
      and appending List or Edit depending on whether a ListPage or EditPage
      is needed. If it fails to find a specific page for the given type, it
      will look for a page named DefaultList or DefaultEdit, respectively. A
      Trails application will always need these pages, and they are created
      automatically when you create a new Trails project.</para>

      <para>So we can change the look and feel of an entire Trails application
      by editing these pages, which are in our
      <computeroutput><filename>WEB-INF</filename></computeroutput> directory.
      We can also make a page for a given Class. Let's check out how this
      works in our blogging application. The <property>entry</property>
      property of our <classname>BlogEntry</classname> page is currently
      rendered as a text field. This isn't really appropriate, so let's change
      this. First let's create a page named BlogEntryEdit. The easiest way to
      do this is to copy <filename>DefaultEdit.page</filename> and
      <filename>DefaultEdit.html</filename> (both are in<filename>
      WEB-INF</filename>) and rename them to
      <filename>BlogEntryEdit.page</filename> and
      <filename>BlogEntryEdit.html</filename>, respectively.</para>

      <para>In this page we could add fields for each of our properties and
      have complete control over how they are presented. However, in this case
      all we really want to do is change the way the
      <property>entry</property> property appears. Fortunately, in Trails, we
      can customize at the property level; we don't have to hard-code the
      presentation of all the other properties if all we want to change is
      one. Let's take a look at the <footnoteref
      linkend="footnote2" /><filename>BlogEntry.html</filename> file:</para>

      <programlisting>&lt;!-- generated by Spindle, http://spindle.sourceforge.net --&gt;

&lt;span jwcid="$content$"&gt;
&lt;body jwcid="@Body"&gt;
    &lt;div class="description" jwcid="@Insert" value="ognl:classDescriptor.shortDescription" /&gt;
    &lt;div jwcid="@Conditional" class="error" condition="ognl:delegate.hasErrors" element="div"&gt;
        Error: &lt;span jwcid="@Delegator" delegate="hognl:delegate.firstError" /&gt;
    &lt;/div&gt;
    &lt;form jwcid="@trails:ObjectForm" model="ognl:model" &gt;
        
	&lt;/form&gt;
    &lt;a href="#" jwcid="@trails:ListAllLink" typeName="ognl:model.class.name" /&gt;
    &lt;a href="#" jwcid="@PageLink" page="Home"&gt;Home&lt;/a&gt;
&lt;/body&gt;
&lt;/span&gt;</programlisting>

      <para>Here we start to get a look at how Trails works under the covers.
      We see two of the Trails Tapestry components, ListAllLink and
      ObjectForm. ListAllLink simply provides a link to the list page for a
      given type. ObjectForm is responsible for providing an edit form for a
      given instance. The instance is passed in via the model parameter. By
      default, ObjectForm will render all the properties of a given object by
      making assumptions based on the type of each property.</para>

      <para>However, the ObjectForm component will also let us override the
      rendering of a property when we so desire. We do this by providing a
      Tapestry Block component with the same name as the property we wish to
      override. Here is what this looks like for our entry property:</para>

      <programlisting>    &lt;form jwcid="@trails:ObjectForm" model="ognl:model" &gt;
        &lt;div jwcid="entry@Block"&gt;
            &lt;tr&gt;
                &lt;td&gt;Entry: &lt;/td&gt;
                &lt;td&gt;&lt;input jwcid="@TextArea" value="ognl:model.entry" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/div&gt;
    &lt;/form&gt;</programlisting>

      <para>It should be noted that the ObjectForm component renders the form
      inputs inside of a table, so when overriding it is necessary to provide
      the table row, including the label and the input, for the property you
      are overriding.</para>

      <para>This should be all we need to do to cause our entry property to be
      rendered in a textarea. We could have used any Tapestry components we
      wish here, as we have complete control over the row that renders this
      property. To see our work in action, go run the
      <command>redeploy</command> target yet again.</para>

      <para><footnote id="footenote1" label="1">
          <para>There is actually another type of page which we won't cover
          during this tutorial, and AddToCollection page. It is used for
          parent-child relationship collections to create and add a new child
          to a parent collection.</para>
        </footnote></para>

      <para><footnote id="footnote2" label="2">
          <para id="footnote2">It's also worth pointing out that by adding
          this Block to the BlogEntryEdit page, we actually affect any Trails
          page that displays a BlogEntry object. This is because the Trails
          components responsible for rendering objects in a form are smart
          enough to look for Blocks that are in the object's edit page.</para>
        </footnote></para>
    </section>

    <section>
      <title>Customizing using bean metadata</title>

      <para>Customizing at the page level is certainly very useful, but there
      are some cases where it may be more convenient to customize using
      metadata. Trails makes use of (some would say abuse of) the java bean
      specification to allow you to specify metadata that can be useful to
      Trails. Here is the metadata that Trails currently understand and how it
      is used.</para>

      <para><informaltable>
          <tgroup cols="2">
            <colspec align="center" />

            <thead>
              <row>
                <entry align="center">Xdoclet bean tag</entry>

                <entry align="center">Trails meaning</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>displayName</entry>

                <entry>This will be used to render a label for a
                property</entry>
              </row>

              <row>
                <entry>shortDescription</entry>

                <entry>Will display at the top of a type's edit page</entry>
              </row>

              <row>
                <entry>hidden</entry>

                <entry>Will cause a field not to display</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>There is a generate-beaninfos target as part of a
      build that will generate beaninfo classes where needed. This may seem
      somewhat in contradiction to the Trails philosophy of avoiding generated
      code, however what we are really generating is metadata classes we don't
      plan on modifying directly.</para>

      <para></para>
    </section>
  </section>
</article>