<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article>
  <title>Trails Manual</title>

  <section>
    <title>This document</title>

    <para>This manual is designed to take over where the Trails java.net
    article leaves off. The java.net article should get you as far as having a
    basic working Trails application. We'll try to go into a bit more detail
    on Trails internals here.</para>
  </section>

  <section>
    <title>Overview</title>

    <para>Trails is a domain driven development framework. Domain driven
    development is really just a fancy word for object oriented programming.
    The goal of DDD is to enable you to focus on developing a rich domain
    model for your application. Trails will automagically expose a web UI for
    your domain model and take care of persisting your domain objects to an
    RDBMS.</para>

    <para>Trails leverages several other frameworks to provide key services
    such as web presentation, database persistence, and dependency injection.
    While detailed knowledge of these frameworks should not be necessary to
    build an application using Trails, a basic understanding will be helpful.
    Here are the frameworks currently used by Trails</para>

    <table>
      <title>Frameworks currently used in Trails</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry><interface>Hibernate</interface></entry>

            <entry>Used for persistence of domain objects to an RDBMS</entry>
          </row>

          <row>
            <entry><interface>Spring</interface></entry>

            <entry>Dependency injection and configuration</entry>
          </row>

          <row>
            <entry><interface>Tapestry</interface></entry>

            <entry>Web application framework</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>
  </section>

  <section>
    <title>How it works</title>

    <para>Trails dynamically creates an application based on your domain
    model. It builds up a set of Descriptor objects which represent the
    metadata about your application. I should say some more stuff here, and I
    will, someday.</para>

    <section>
      <title>Creating a project</title>

      <para>The main Trails build.xml file contains a create-project target
      which creates a new project by making a copy of the base_app
      subdirectory in the selected location. Ant token substitution is use to
      substitute the new project name in the appropriate files. This target
      will also copy an apt-ant.jar into ANT_HOME/lib if it doesn't exist
      there already. This jar contains the apt task for Ant 1.6, and will not
      function properly unless it is installed in this directory. This task
      should hopefully be included in Ant 1.7 so this will no longer be
      necessary when Ant 1.7 is released.</para>
    </section>
  </section>

  <section>
    <title>Trails and Spring</title>

    <para>A Trails application created with the create-project target will
    have a <filename>WEB-INF/applicationContext.xml</filename> file which
    contains the Spring configuration. There are 2 main services that make
    Trails go.</para>

    <section>
      <title>persistenceService</title>

      <para>This service implements persistence in Trails. It implements the
      PersistenceService interface. The only existing implementation,
      HibernatePersistenceService, leverages Spring's Hibernate support and
      extends HibernateDaoSupport. It would be possible to implement this
      service using another ORM framework, but currently it is tied to the
      Hibernate Criteria stuff. This is because there is no standard OO
      criteria API that I am aware of. So this would have to change if someone
      wanted to implement a JDO persistence service, for example.</para>

      <para>See the Hibernate Spring documentation for more information on how
      to configure transaction handling. It would also be possible to
      implement per-type persistence services by configuring AOP interceptors
      around this service. An interceptor could be configured to delegate to a
      different implementation of PersistenceService for a specific type. Need
      an example of this.</para>
    </section>

    <section>
      <title>descriptorService</title>

      <para>This service builds up the metadata Trails uses to produce a UI.
      It's default implementation gets the basic data about an object using
      the BeanInfo stuff. It then hands off to a "pipeline" of
      DescriptorDecorators. Right the two decorators in the pipeline by
      default are:</para>

      <itemizedlist>
        <listitem>
          <para>HibernateDescriptorDecorator adds information from the
          Hibernate metadata, including relationship information</para>
        </listitem>

        <listitem>
          <para>AnnotationDecorator adds information by processing Trails
          annotations</para>
        </listitem>
      </itemizedlist>

      <para></para>
    </section>

    <section>
      <title>Open Session In View Filter</title>

      <para>Trails uses the Spring supplied filter to open and close sessions
      around a request so that lazy loaded relationships work properly.</para>
    </section>
  </section>

  <section>
    <title>Trails and Tapestry</title>

    <para>TBD, but for now see the Component Reference</para>

    <section>
      <title>Trails Pages</title>

      <para>There are 3 types of pages in Trails</para>
    </section>
  </section>

  <section>
    <title>Trails and Hibernate</title>

    <para>Trails uses Hibernate for persistence, as mentioned earlier.</para>

    <section>
      <title>Hibernate Annotations</title>

      <para>Trails makes use of the Hibernate Annotations subproject that
      implements the JSR-220 annotations. Trails also generates a
      hibernate.cfg.xml file in the project ant build by using the new Java5
      Apt (Annotation Processor Tool) via an ant task. The
      HibernateAnnotationProcessor which is invoked by Apt is responsible for
      adding entries to hibernate.cfg.xml for each class annotated with an
      @Entity annotation. This a replacement for the Spring classpath: mapping
      directory locations thing.</para>

      <para>Trails also makes use of the new validation annotations in the
      latest release of Hibernate annotations. These allow you to add
      validation by annotating your domain classes. These validations
      currently happen on the server side only (no client side javascript).
      Validation failure messages are composed by using the display name of
      the property and concatenating the failure message from the validation.
      Eg, if the validation failure message is "length must be between 10 and
      20" and the property name is userName, the full message displayed on the
      page will be "User Name must be between 10 and 20".</para>
    </section>

    <section>
      <title>Assigned ids</title>

      <para>In most cases, it is easiest to let ids be generated. However,
      Trails does support assigned ids. A TrailsInterceptor is configured in
      the Hibernate configuration that is responsible for notifying an object
      when it is saved or loaded and implementing isUnsaved(). The
      AssignedIdentifierAspect will introduce the necessary methods and
      property to track when an object is saved. It will do this for any class
      that implements the HasAssignedIdentifier interface.</para>

      <para>An easy way to make sure all your classes which have assigned
      identifiers get handled properly is to have each object implement
      HasAssignedIdentifier or to write an Aspect which introduces
      HasAssignedIdentifier onto the desired classes.</para>
    </section>
  </section>

  <section>
    <title>First things first</title>

    <para></para>

    <para>So that said, hopefully it logically follows that the first thing
    you are going to do in a Trails application is develop an object. This
    should be a POJO with JSR-220 persistencea annotations which tell
    Hibernate how to persist your objects to an RDBMS.</para>

    <para>So let's start with a very simple object to represent a Blog.</para>

    <programlisting>package org.trails.tutorial;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class Blog
{
    private Integer id;
    
    private String name;
    
    private String author;
    
    /**
     * @hibernate.property 
     * @return Returns the author.
     */
    public String getAuthor()
    {
        return author;
    }
    /**
     * @param author The author to set.
     */
    public void setAuthor(String author)
    {
        this.author = author;
    }
    /**
     * @return Returns the id.
     * @hibernate.id
     *   generator-class = "native"
     */
    public Integer getId()
    {
        return id;
    }
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    /**
     * @hibernate.property
     * @return Returns the name.
     */
    public String getName()
    {
        return name;
    }
    /**
     * @param name The name to set.
     */
    public void setName(String name)
    {
        this.name = name;
    }
}

</programlisting>

    <para>So this is a what the simplest Trails application looks like: a POJO
    with some <ulink url="http://xdoclet.sourceforge.net/hibernate/">Xdoclet
    comments</ulink>. The Xdoclet comments are optional, but since Trails uses
    Hibernate for persistence by default you will need to provide the
    Hibernate mapping files. By using Xdoclet comments, your project's
    build.xml file will invoke hibernatedoclet to produce these mappings
    automatically. We have our blog class with a couple of properties for
    <property>name</property> and <property>author</property>, and an Integer
    <property>id</property> property. It's worth pointing out that we need
    this id property. In a Trails application, we need an identifier property
    for Hibernate to be happy. A totally synthetic property with no intrinsic
    meaning is usually best. Yes, purists will argue this is in an intrusion
    to our lovely pure OO domain model. I won't argue, but for now, in Trails
    this is just the price of RDBMS persistence.</para>

    <para>Ok, enough talk, let's see what this looks like. Startup your Tomcat
    instance, if you don't already have it running. Then run <command>ant
    deploy</command>. Go the url for your application, which if you named your
    application <literal>blogger</literal> and run tomcat on port 8080 would
    be <ulink url="???">http://localhost:8080/blog</ulink>. On the first page
    of the application, you will see a link to the List Blogs page. From here,
    you can create a New Blog, etc.</para>
  </section>

  <section>
    <title>Relationships</title>

    <para>At this point we have a fully functional (though very minimal) web
    application complete with database persistence. But it's not very
    interesting. In order to build a useful application, we will need more
    than CRUD screens against each object. We also need to manipulate the
    relationships between those objects.</para>

    <section>
      <title>One-to-many relationships</title>

      <para>As the next step in building a Blog application, we really need to
      add blog entries to a Blog. First, let's create a BlogEntry
      class:</para>

      <programlisting>
package org.trails.tutorial;

import java.util.Date;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class BlogEntry
{
    private Integer id;
    
    private String entry;
    
    private Date publishDate;
    
    private String title;
    
    /**
     * @hibernate.property
     * @return Returns the entry.
     */
    public String getEntry()
    {
        return entry;
    }
    
    /**
     * @param entry The entry to set.
     */
    public void setEntry(String entry)
    {
        this.entry = entry;
    }
    
    /**
     * @hibernate.id
     *   generator-class = "native"
     * @return Returns the id.
     */
    public Integer getId()
    {
        return id;
    }
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    
    /**
     * @hibernate.property
     * @return Returns the publishDate.
     */
    public Date getPublishDate()
    {
        return publishDate;
    }
    /**
     * @param publishDate The publishDate to set.
     */
    public void setPublishDate(Date publishDate)
    {
        this.publishDate = publishDate;
    }
    
    /**
     * @return Returns the title.
     */
    public String getTitle()
    {
        return title;
    }
    /**
     * @param title The title to set.
     */
    public void setTitle(String title)
    {
        this.title = title;
    }
    
    public String toString() { return title; }
    
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj)
    {
        return ((BlogEntry)obj).getId().equals(getId());
    }
}
</programlisting>

      <para>One important thing is worth pointing out: the
      <methodname>toString()</methodname> method. This method is more than
      just a good idea, in Trails it is vital to displaying this object
      properly. When an object can be related to another object (such as
      <classname>Blog</classname>), Trails will use the
      <methodname>toString()</methodname> method in rendering these objects.
      In this example when editing <classname>Blog</classname> we will see all
      the <classname>BlogEntry</classname>s. Trails will use the toString()
      method of <classname>BlogEntry</classname> to display these. Let's start
      by adding a Set of blog entries to our Blog class:</para>

      <programlisting>    /**
     * @return Returns the entries.
     * @hibernate.set cascade="all-delete-orphan"
     * @hibernate.collection-key column="ENTRY_ID"
     * @hibernate.collection-one-to-many class="org.trails.tutorial.BlogEntry"
     */
    public Set getEntries()
    {
        return entries;
    }
    
    /**
     * @param entries The entries to set.
     */
    public void setEntries(Set entries)
    {
        this.entries = entries;
    }</programlisting>

      <para>There's a couple of things to point out here. The first of these
      is that this is a one-to-many relationship from Blog to BlogEntry.
      Trails will present an appropriate UI to interact with many-to-one and
      one-to-many relationships. We will see a many-to-one relationship
      example later.</para>

      <para>Notice the Xdoclet comment here. This is all necessary to tell
      Hibernate how to persist this Set. In addition, the
      <computeroutput>cascade="all-delete-orphan"</computeroutput> is
      particularly significant to Trails. Based on this, Trails assumes that
      this is a child relationship, which means that it will be rendered with
      a component that will allow you insert new
      <classname>BlogEntry</classname>s and remove them. If this was not a
      child relationship, you would also be able to add existing BlogEntrys,
      and Trails would present a list of all BlogEntrys to choose from. Since
      it really doesn't make sense to choose BlogEntrys from (possibly) a
      different Blog, we want this to be a child relationship.</para>

      <para>Ok, enough talk, let's see this in action. Run the
      <command>redeploy</command> target to see our application in action. We
      now have are able to create a Blog and create BlogEntrys within that
      Blog.</para>

      <para><tip>
          <para>By default, for ease of demoing, Trails ships with HSQL
          database running in file mode. This will not handle redeploys
          gracefully due to file locking issues with HSQL. You may therefore
          want to use MySQL or run HSQL in server mode.</para>
        </tip></para>
    </section>

    <section>
      <title>Many-to-one relationships</title>

      <para>Another typical feature we would like to have in a blogging
      application is the ability to categorize our blog entries. First, let's
      create a <classname>Category</classname> class.</para>

      <programlisting>package org.trails.tutorial;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class Category
{
    private Integer id;
    
    private String name;
    
    /**
     * @hibernate.id
     *   generator-class = "native"
     * @return Returns the id.
     */
    public Integer getId()
    {
        return id;
    }
    
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    
    /**
     * @return Returns the name.
     * @hibernate.property
     */
    public String getName()
    {
        return name;
    }
    /**
     * @param name The name to set.
     */
    public void setName(String name)
    {
        this.name = name;
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj)
    {
        return ((Category)obj).getId().equals(getId());
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#toString()
     */
    public String toString()
    {
        return getName();
    }
}
</programlisting>

      <para>Here again it is important for us to override the
      <methodname>equals</methodname> and <methodname>toString</methodname>
      methods. We need the <methodname>toString</methodname> method to
      correctly display categories in a select list on the BlogEntry class, as
      we shall see in a moment. Now we need to add a category field to the
      BlogEntry class:</para>

      <programlisting>    private Category category;
    
    /**
     * @hibernate.many-to-one 
     */
    public Category getCategory()
    {
        return category;
    }
    
    /**
     * @param category The category to set.
     */
    public void setCategory(Category category)
    {
        this.category = category;
    }</programlisting>

      <para>As you can see this is actually quite a bit simpler than the
      one-to-many. When we run the <command>redeploy</command> target we will
      see that BlogEntry page now has a select list of categories. Of course
      we will need to create some categories before we have any to add.</para>
    </section>
  </section>

  <section>
    <title>Customization</title>

    <para>So far we've seen what Trails can do just based on our object model
    alone. Trails uses the approach of assuming as much as we possibly can,
    but lets us override those assumptions whenever we need to. Let's explore
    how we can customize our blogging application. In Trails, there are two
    basic ways we can customize.</para>

    <para></para>

    <section>
      <title>Customizing pages in Trails</title>

      <para>Right now, Trails uses Tapestry as it's web MVC framework, so all
      pages in Trails are Tapestry pages. <footnoteref id="footnoteref1"
      linkend="footenote1" />There are 2 basic types of pages in Trails: pages
      which extend <classname>ListPage</classname> and pages which extend
      <classname>EditPage</classname>. Pages which extend ListPage display a
      list of objects of a given type, while those that extend
      <classname>EditPage</classname> allow a user to edit a selected
      instance.</para>

      <para>Trails determines which specific page to use by first attempting
      to find a page for a specific class by calling
      <methodname>cycle.getPage()</methodname> with the unqualified class name
      and appending List or Edit depending on whether a ListPage or EditPage
      is needed. If it fails to find a specific page for the given type, it
      will look for a page named DefaultList or DefaultEdit, respectively. A
      Trails application will always need these pages, and they are created
      automatically when you create a new Trails project.</para>

      <para>So we can change the look and feel of an entire Trails application
      by editing these pages, which are in our
      <computeroutput><filename>WEB-INF</filename></computeroutput> directory.
      We can also make a page for a given Class. Let's check out how this
      works in our blogging application. The <property>entry</property>
      property of our <classname>BlogEntry</classname> page is currently
      rendered as a text field. This isn't really appropriate, so let's change
      this. First let's create a page named BlogEntryEdit. The easiest way to
      do this is to copy <filename>DefaultEdit.page</filename> and
      <filename>DefaultEdit.html</filename> (both are in<filename>
      WEB-INF</filename>) and rename them to
      <filename>BlogEntryEdit.page</filename> and
      <filename>BlogEntryEdit.html</filename>, respectively.</para>

      <para>In this page we could add fields for each of our properties and
      have complete control over how they are presented. However, in this case
      all we really want to do is change the way the
      <property>entry</property> property appears. Fortunately, in Trails, we
      can customize at the property level; we don't have to hard-code the
      presentation of all the other properties if all we want to change is
      one. Let's take a look at the <footnoteref
      linkend="footnote2" /><filename>BlogEntry.html</filename> file:</para>

      <programlisting>&lt;!-- generated by Spindle, http://spindle.sourceforge.net --&gt;

&lt;span jwcid="$content$"&gt;
&lt;body jwcid="@Body"&gt;
    &lt;div class="description" jwcid="@Insert" value="ognl:classDescriptor.shortDescription" /&gt;
    &lt;div jwcid="@Conditional" class="error" condition="ognl:delegate.hasErrors" element="div"&gt;
        Error: &lt;span jwcid="@Delegator" delegate="hognl:delegate.firstError" /&gt;
    &lt;/div&gt;
    &lt;form jwcid="@trails:ObjectForm" model="ognl:model" &gt;
        
	&lt;/form&gt;
    &lt;a href="#" jwcid="@trails:ListAllLink" typeName="ognl:model.class.name" /&gt;
    &lt;a href="#" jwcid="@PageLink" page="Home"&gt;Home&lt;/a&gt;
&lt;/body&gt;
&lt;/span&gt;</programlisting>

      <para>Here we start to get a look at how Trails works under the covers.
      We see two of the Trails Tapestry components, ListAllLink and
      ObjectForm. ListAllLink simply provides a link to the list page for a
      given type. ObjectForm is responsible for providing an edit form for a
      given instance. The instance is passed in via the model parameter. By
      default, ObjectForm will render all the properties of a given object by
      making assumptions based on the type of each property.</para>

      <para>However, the ObjectForm component will also let us override the
      rendering of a property when we so desire. We do this by providing a
      Tapestry Block component with the same name as the property we wish to
      override. Here is what this looks like for our entry property:</para>

      <programlisting>    &lt;form jwcid="@trails:ObjectForm" model="ognl:model" &gt;
        &lt;div jwcid="entry@Block"&gt;
            &lt;tr&gt;
                &lt;td&gt;Entry: &lt;/td&gt;
                &lt;td&gt;&lt;input jwcid="@TextArea" value="ognl:model.entry" /&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/div&gt;
    &lt;/form&gt;</programlisting>

      <para>It should be noted that the ObjectForm component renders the form
      inputs inside of a table, so when overriding it is necessary to provide
      the table row, including the label and the input, for the property you
      are overriding.</para>

      <para>This should be all we need to do to cause our entry property to be
      rendered in a textarea. We could have used any Tapestry components we
      wish here, as we have complete control over the row that renders this
      property. To see our work in action, go run the
      <command>redeploy</command> target yet again.</para>

      <para><footnote id="footenote1" label="1">
          <para>There is actually another type of page which we won't cover
          during this tutorial, and AddToCollection page. It is used for
          parent-child relationship collections to create and add a new child
          to a parent collection.</para>
        </footnote></para>

      <para><footnote id="footnote2" label="2">
          <para id="footnote2">It's also worth pointing out that by adding
          this Block to the BlogEntryEdit page, we actually affect any Trails
          page that displays a BlogEntry object. This is because the Trails
          components responsible for rendering objects in a form are smart
          enough to look for Blocks that are in the object's edit page.</para>
        </footnote></para>
    </section>

    <section>
      <title>Customizing using bean metadata</title>

      <para>Customizing at the page level is certainly very useful, but there
      are some cases where it may be more convenient to customize using
      metadata. Trails makes use of (some would say abuse of) the java bean
      specification to allow you to specify metadata that can be useful to
      Trails. Here is the metadata that Trails currently understand and how it
      is used.</para>

      <para><informaltable>
          <tgroup cols="2">
            <colspec align="center" />

            <thead>
              <row>
                <entry align="center">Xdoclet bean tag</entry>

                <entry align="center">Trails meaning</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>displayName</entry>

                <entry>This will be used to render a label for a
                property</entry>
              </row>

              <row>
                <entry>shortDescription</entry>

                <entry>Will display at the top of a type's edit page</entry>
              </row>

              <row>
                <entry>hidden</entry>

                <entry>Will cause a field not to display</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>There is a generate-beaninfos target as part of a
      build that will generate beaninfo classes where needed. This may seem
      somewhat in contradiction to the Trails philosophy of avoiding generated
      code, however what we are really generating is metadata classes we don't
      plan on modifying directly.</para>

      <para></para>
    </section>
  </section>
</article>