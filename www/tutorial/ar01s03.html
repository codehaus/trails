<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Relationships</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Trails Tutorial"><link rel="up" href="index.html" title="Trails Tutorial"><link rel="previous" href="ar01s02.html" title="2.&nbsp;First things first"><link rel="next" href="ar01s04.html" title="4.&nbsp;Customization"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Relationships</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e71"></a>3.&nbsp;Relationships</h2></div></div><div></div></div><p>At this point we have a fully functional (though very minimal) web application complete with database persistence. But it's not very interesting. In order to build a useful application, we will need more than CRUD screens against each object. We also need to manipulate the relationships between those objects.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e76"></a>3.1.&nbsp;One-to-many relationships</h3></div></div><div></div></div><p>As the next step in building a Blog application, we really need to add blog entries to a Blog. First, let's create a BlogEntry class:</p><pre class="programlisting">
package org.trails.tutorial;

import java.util.Date;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class BlogEntry
{
    private Integer id;
    
    private String entry;
    
    private Date publishDate;
    
    private String title;
    
    /**
     * @hibernate.property
     * @return Returns the entry.
     */
    public String getEntry()
    {
        return entry;
    }
    
    /**
     * @param entry The entry to set.
     */
    public void setEntry(String entry)
    {
        this.entry = entry;
    }
    
    /**
     * @hibernate.id
     *   generator-class = "native"
     * @return Returns the id.
     */
    public Integer getId()
    {
        return id;
    }
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    
    /**
     * @hibernate.property
     * @return Returns the publishDate.
     */
    public Date getPublishDate()
    {
        return publishDate;
    }
    /**
     * @param publishDate The publishDate to set.
     */
    public void setPublishDate(Date publishDate)
    {
        this.publishDate = publishDate;
    }
    
    /**
     * @return Returns the title.
     */
    public String getTitle()
    {
        return title;
    }
    /**
     * @param title The title to set.
     */
    public void setTitle(String title)
    {
        this.title = title;
    }
    
    public String toString() { return title; }
    
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj)
    {
        return ((BlogEntry)obj).getId().equals(getId());
    }
}
</pre><p>One important thing is worth pointing out: the <tt class="methodname">toString()</tt> method. This method is more than just a good idea, in Trails it is vital to displaying this object properly. When an object can be related to another object (such as <tt class="classname">Blog</tt>), Trails will use the <tt class="methodname">toString()</tt> method in rendering these objects. In this example when editing <tt class="classname">Blog</tt> we will see all the <tt class="classname">BlogEntry</tt>s. Trails will use the toString() method of <tt class="classname">BlogEntry</tt> to display these. Let's start by adding a Set of blog entries to our Blog class:</p><pre class="programlisting">    /**
     * @return Returns the entries.
     * @hibernate.set cascade="all-delete-orphan"
     * @hibernate.collection-key column="ENTRY_ID"
     * @hibernate.collection-one-to-many class="org.trails.tutorial.BlogEntry"
     */
    public Set getEntries()
    {
        return entries;
    }
    
    /**
     * @param entries The entries to set.
     */
    public void setEntries(Set entries)
    {
        this.entries = entries;
    }</pre><p>There's a couple of things to point out here. The first of these is that this is a one-to-many relationship from Blog to BlogEntry. Trails will present an appropriate UI to interact with many-to-one and one-to-many relationships. We will see a many-to-one relationship example later.</p><p>Notice the Xdoclet comment here. This is all necessary to tell Hibernate how to persist this Set. In addition, the <tt class="computeroutput">cascade="all-delete-orphan"</tt> is particularly significant to Trails. Based on this, Trails assumes that this is a child relationship, which means that it will be rendered with a component that will allow you insert new <tt class="classname">BlogEntry</tt>s and remove them. If this was not a child relationship, you would also be able to add existing BlogEntrys, and Trails would present a list of all BlogEntrys to choose from. Since it really doesn't make sense to choose BlogEntrys from (possibly) a different Blog, we want this to be a child relationship.</p><p>Ok, enough talk, let's see this in action. Run the <span><b class="command">redeploy</b></span> target to see our application in action. We now have are able to create a Blog and create BlogEntrys within that Blog.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>By default, for ease of demoing, Trails ships with HSQL database running in file mode. This will not handle redeploys gracefully due to file locking issues with HSQL. You may therefore want to use MySQL or run HSQL in server mode.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e124"></a>3.2.&nbsp;Many-to-one relationships</h3></div></div><div></div></div><p>Another typical feature we would like to have in a blogging application is the ability to categorize our blog entries. First, let's create a <tt class="classname">Category</tt> class.</p><pre class="programlisting">package org.trails.tutorial;

/**
 * @author fus8882
 * @hibernate.class
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class Category
{
    private Integer id;
    
    private String name;
    
    /**
     * @hibernate.id
     *   generator-class = "native"
     * @return Returns the id.
     */
    public Integer getId()
    {
        return id;
    }
    
    /**
     * @param id The id to set.
     */
    public void setId(Integer id)
    {
        this.id = id;
    }
    
    /**
     * @return Returns the name.
     * @hibernate.property
     */
    public String getName()
    {
        return name;
    }
    /**
     * @param name The name to set.
     */
    public void setName(String name)
    {
        this.name = name;
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object obj)
    {
        return ((Category)obj).getId().equals(getId());
    }
    
    /* (non-Javadoc)
     * @see java.lang.Object#toString()
     */
    public String toString()
    {
        return getName();
    }
}
</pre><p>Here again it is important for us to override the <tt class="methodname">equals</tt> and <tt class="methodname">toString</tt> methods. We need the <tt class="methodname">toString</tt> method to correctly display categories in a select list on the BlogEntry class, as we shall see in a moment. Now we need to add a category field to the BlogEntry class:</p><pre class="programlisting">    private Category category;
    
    /**
     * @hibernate.many-to-one 
     */
    public Category getCategory()
    {
        return category;
    }
    
    /**
     * @param category The category to set.
     */
    public void setCategory(Category category)
    {
        this.category = category;
    }</pre><p>As you can see this is actually quite a bit simpler than the one-to-many. When we run the <span><b class="command">redeploy</b></span> target we will see that BlogEntry page now has a select list of categories. Of course we will need to create some categories before we have any to add.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;First things first&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Customization</td></tr></table></div></body></html>